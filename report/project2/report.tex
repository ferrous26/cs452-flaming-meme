\documentclass[pdftex,10pt,a4paper]{article}
\usepackage{../cs452}

\begin{document}

\finalprojectmake

\section*{Overview}

This goals of our train project is to  adds basic train control functionality.
From the terminal you can both track, in real time, the position of
the train on the track and route it to a sensor location. Train track
state is updated live on screen as the trains travel around the track.
trains travel around the track.

Commands issued into the terminal can manipulate trains and
switches, as well as monitor sensors. Trains can start, stop, toggle
lights and sound effects, and adjust speed. Switches can be toggled or
explicitly set to the straight or curved state.

The terminal displays information about current state
of the trains and switches, including a short history of the most
recent sensor activations.


\section*{Operation Instructions}

A pre-compiled kernel exists at
\ttt{/u/cs452/tftp/ARM/marada/m1.elf}, which can be loaded with
RedBoot using the following command:

\begin{center}
  \ttt{load -h 10.15.167.4 ARM/marada/m3.elf; go}
\end{center}

Notice that no offset should be specified for the load instruction.

The source code for the kernel exists in \ttt{/u3/marada/control3/},
and can be compiled with the following command chain:

\begin{center}
  \ttt{cd /u3/marada/control3 \&\& /u/cs444/bin/rake local}
\end{center}

Which will produce a \ttt{kernel.elf} file in the same directory as
the makefile, built in release mode with benchmarking enabled.

After Initialization, the kernel will ask you to select a track,
\ttt{a} or \ttt{b} so that it can load the correct track data,
initialize the track, and setup the train drivers and all other
supporting tasks.  At this point commands can be entered and should be
echoed back on the line titled ``TERM> ''. Keys pressed should be
echoed back at the command prompt in place of the white
cursor. Pressing the return key will confirm a command and cause it to
be processed. An online listing of the commands can be printed by
entering an empty command. The program supports all commands from the
previous milestone as well new commands mentioned below.

\subsection*{Submitted Files}
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info_headers.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}
\newpage
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info_impls.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}

\newpage

\part*{Task Diagram}

\begin{center}
\includegraphics[scale=0.5]{tasks}
\end{center}


\part*{Milestone One}

\section*{The Track}

To represent the track we use the data structure and data given on the
course web site. However, we have modified the data to store track
distances with extra (artificial) precision in order to avoid rounding
errors introduced by using integer math operations in calculations.

In addition, we have also remeasured track B to ensure that the given
data is accurate. While performing new measurements we changed the fiducial
point of various track nodes to better categorize track nodes as being
straight or curved for use during calibration.

The new measurements are used in combination with a classification for each
track section that is between a pair of sensors. The classification
allows us to assign different parameters to a train dependent on which
part of the track the train is currently travelling through. The
primary use for velocity estimates.

\section*{Train Calibration}

In order to measure train velocity, we calculated the time delta of
the train travelling between sensors at a constant speed
setting. Various sensor pairings were measured multiple times for each
of the trains.

For the sake of this milestone, we have limited the trains to speeds 6
through 12. We found that speeds lower than 6 often cause issues on
the track by getting the train stuck around corners, and speeds
greater than 12 have inconsistent and unpredictable measurements.

The different sensor pairings allow us to create baseline values for
each track node classification so that we can estimate a different
velocity for the train on a straight section of track compared to the
train trying to navigate around a corner.

We found that four different classifications: \ttt{STRAIGHT},
\ttt{CURVED}, \ttt{STRAIGHT\_TURNOUT}, \ttt{CURVED\_TURNOUT}.

In order to get acceleration profiles, we filmed one of each type of
train (except train 51) stopping at a sensor. Next to the track is a
measuring tape, and by counting frames taken for the train to get from
points on the measuring tape, we are able to map distance travelled
against time with a high precision and calculate velocity and
acceleration functions for trains.

The video was recorded at 60 frames per second to accommodate as much
precision as possible, but because the kernel itself has a clock
running at 100 Hz, we are able to poll sensors the velocity
measurements had a higher precision when measured with the
computer. Though, the accuracy of the computer assisted measurements
suffers from error introduced by non-uniform latency in sensor polling.

\subsection*{Feedback}

To compensate for initial measurements, we use live feedback at runtime
to adjust our velocity measurements. We track our estimated time
between sensors based on the current velocity estimate, and then
compare that value against the live measurement. A weighted averaging of
the two values is fed back into the system and used for future estimates.
The weights on the average are runtime configurable in our system, with
the default being an 80/20 split between estimate and actual measurements
respectively.

As a safety for feedback, we have a threshold delta value. If the
difference between estimate and actual velocities is greater than the
threshold value, then the actual velocity is not used for feedback and
the difference is logged to the terminal.

To keep baseline estimates up to date, we have implemented a \ttt{dp}
command that will log to the terminal, in CSV format, the current
velocity estimates for each speed and each track classification. A script
can then take the CSV output and generate C code which can easily be
copy-pasted over place of the existing values.

\subsection*{Console Tweaking}

long with the feedback ratio, we also allow for the feedback threshold
and a stop distance padding to be configured via the terminal. Each of
these tweakable values can be configured via terminal commands.

\section*{Tracking}

Since we only need to support tracking one train, we are able to poll
all of the sensors to make sure that the train remains on the path
calculated by the go command. The train sets its position to be at the
last sensor triggered and associates it with the time the the sensor was
triggered. Whenever the train is woken up, it looks at the
current time and recalculates its position using its stored velocity.

We use distance measurements for parameters, because speed and
consequently time, will vary from train to train, and track piece to
track piece. To set up the train direction the application assumes that
the front of the train is pointed towards a sensor belonging to bank B
and the the tail of the train is pointing towards a sensor belonging to
any other bank.

Right now every train will create a task to notify it when a sensor was hit.
This was done so later when we need to track multiple trains in the system we
can use more complex logic to decide which sensors the current train has a
possibility of hitting helping us more carefully choose which sensors to show
interest in.

Using the \ttt{wh} command, and a train number, the current position
estimate for a train can be calculated and printed to the terminal. The
position is estimated using the last known sensor hit and the current
velocity. Acceleration information is not yet factored in to the
location of a train.

\section*{Path Finding}

In order to find the path from any given node on the track we make use of
Dijkstra's algorithm so that we can get the shortest path in terms of distance.
Since we don't yet support backwards path finding, reverse rules have
been excluded to ensure that no paths requiring reversing the train
will be generated by the algorithm. This will allow us to easily add
support for reverse paths later once the train driver is able to
handle the instructions.

The path is returned to the train driver as a collection of waypoints that the
train should expect to see on its way to reaching the destination along with
how far along the path the waypoint is. There are 3 different types of
waypoints returned by the train: first is the sensor waypoint, this is a sensor
that the train should expect to trip over the path to the destination; second
is the turnout waypoint, this is a track turnout and switch orientation that
that the driver must obey to keep the train routed on the same path; third is
the reverse way point, it indicates that the train must change its direction to
reach the next node.

Since reverse path are not currently supported the reverse waypoint is just used
to notify the driver that it is approaching its destination from the reverse
direction.

A path can be generated for the train using the \ttt{go} command and
specifying a train number, sensor bank, sensor number, and offset. For
example, \ttt{go 49 B 16 0} will send train 49 to sensor B16.


\part*{Milestone Two}

\section*{Positioning}

\section*{Reversing The Train}

\section*{Short Moves}

\section*{Sensor Attribution}

\section*{Reservations}


\part*{Final Project}

\section*{Path Finding Options}

\section*{Inter-train Communication}

\section*{The Chasing Game}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
