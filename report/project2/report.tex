\documentclass[pdftex,10pt,a4paper]{article}
\usepackage{../cs452}

\begin{document}

\finalprojectmake

\section*{Overview}

This document outlines the functionality and design of our final train project
separated into the various milestones the have gone into building our final OS.

This milestone allows for trains to be controlled via terminal where they can
be router from their current position to any of the sensors on the track. In
addition trains can start, stop, chase each other, and sound their horn all
using commands issued by the terminal.

The terminal display holds real time information about the current state of the
trains and switches including a short history of the recent sensor activations,
the next steps a train driver intends to take while routing a train, A trains
current position and the track nodes that the train has reserved.

\section*{Operation Instructions}

A pre-compiled kernel exists at
\ttt{/u/cs452/tftp/ARM/marada/m1.elf}, which can be loaded with
RedBoot using the following command:

\begin{center}
  \ttt{load -h 10.15.167.4 ARM/marada/m3.elf; go}
\end{center}

Notice that no offset should be specified for the load instruction.

The source code for the kernel exists in \ttt{/u3/marada/control3/},
and can be compiled with the following command chain:

\begin{center}
  \ttt{cd /u3/marada/control3 \&\& /u/cs444/bin/rake local}
\end{center}

Which will produce a \ttt{kernel.elf} file in the same directory as
the makefile, built in release mode with benchmarking enabled.

After Initialization, the kernel will ask you to select a track,
\ttt{a} or \ttt{b} so that it can load the correct track data,
initialize the track, and setup the train drivers and all other
supporting tasks.  At this point commands can be entered and should be
echoed back on the line titled ``TERM$>$''. Keys pressed should be
echoed back at the command prompt in place of the white
cursor. Pressing the return key will confirm a command and cause it to
be processed. An online listing of the commands can be printed by
entering an empty command. The program supports all commands from the
previous milestone as well new commands mentioned below.

\subsection*{Submitted Files}
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info_headers.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}
\newpage
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info_impls.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}

\newpage

\part*{Task Diagram}

The graph on the following page shows all the tasks present in our
system after initialization.

Tasks are grouped by function, and the directed edges indicate
communication using \ttt{Send}. Courier tasks have an octagonal shape,
event notifiers use a diamond shape, and all other tasks have a
rectangular shape.

Communication channels between tasks that only exist for task
initialization, such as registering with the name server, is not shown
as it would make an already complicated graph impossible to read.

\newpage

\begin{center}
\includegraphics[scale=0.3, clip=true, trim=5mm 0 0 0]{tasks}
\end{center}


\part*{Milestone One}

The goal of this milestone is to add basic train control functionality. From the
terminal you can both track, in real time, the position of the train on the
track and route it to a sensor location. Train track state is updated live on
screen as the trains travel around the track.

\section*{The Track}

To represent the track we use the data structure and data given on the
course web site. However, we have modified the data to store track
distances with extra (artificial) precision in order to avoid rounding
errors introduced by using integer math operations in calculations.

In addition, we have also remeasured track B to ensure that the given
data is accurate. While performing new measurements we changed the fiducial
point of various track nodes to better categorize track nodes as being
straight or curved for use during calibration.

The new measurements are used in combination with a classification for each
track section that is between a pair of sensors. The classification
allows us to assign different parameters to a train dependent on which
part of the track the train is currently travelling through. The
primary use for velocity estimates.

\section*{Train Calibration}

In order to measure train velocity, we calculated the time delta of
the train travelling between sensors at a constant speed
setting. Various sensor pairings were measured multiple times for each
of the trains.

For the sake of this milestone, we have limited the trains to speeds 6
through 12. We found that speeds lower than 6 often cause issues on
the track by getting the train stuck around corners, and speeds
greater than 12 have inconsistent and unpredictable measurements.

The different sensor pairings allow us to create baseline values for
each track node classification so that we can estimate a different
velocity for the train on a straight section of track compared to the
train trying to navigate around a corner.

We found that four different classifications: \ttt{STRAIGHT},
\ttt{CURVED}, \ttt{STRAIGHT\_TURNOUT}, \ttt{CURVED\_TURNOUT}.

In order to get acceleration profiles, we filmed one of each type of
train (except train 51) stopping at a sensor. Next to the track is a
measuring tape, and by counting frames taken for the train to get from
points on the measuring tape, we are able to map distance travelled
against time with a high precision and calculate velocity and
acceleration functions for trains.

The video was recorded at 60 frames per second to accommodate as much
precision as possible, but because the kernel itself has a clock
running at 100 Hz, we are able to poll sensors the velocity
measurements had a higher precision when measured with the
computer. Though, the accuracy of the computer assisted measurements
suffers from error introduced by non-uniform latency in sensor polling.

\subsection*{Feedback}

To compensate for initial measurements, we use live feedback at runtime
to adjust our velocity measurements. We track our estimated time
between sensors based on the current velocity estimate, and then
compare that value against the live measurement. A weighted averaging of
the two values is fed back into the system and used for future estimates.
The weights on the average are runtime configurable in our system, with
the default being an 80/20 split between estimate and actual measurements
respectively.

As a safety for feedback, we have a threshold delta value. If the
difference between estimate and actual velocities is greater than the
threshold value, then the actual velocity is not used for feedback and
the difference is logged to the terminal.

To keep baseline estimates up to date, we have implemented a \ttt{dp}
command that will log to the terminal, in CSV format, the current
velocity estimates for each speed and each track classification. A script
can then take the CSV output and generate C code which can easily be
copy-pasted over place of the existing values.

\subsection*{Console Tweaking}

long with the feedback ratio, we also allow for the feedback threshold
and a stop distance padding to be configured via the terminal. Each of
these tweakable values can be configured via terminal commands.

\section*{Tracking}

Since we only need to support tracking one train, we are able to poll
all of the sensors to make sure that the train remains on the path
calculated by the go command. The train sets its position to be at the
last sensor triggered and associates it with the time the the sensor was
triggered. Whenever the train is woken up, it looks at the
current time and recalculates its position using its stored velocity.

We use distance measurements for parameters, because speed and
consequently time, will vary from train to train, and track piece to
track piece. To set up the train direction the application assumes that
the front of the train is pointed towards a sensor belonging to bank B
and the the tail of the train is pointing towards a sensor belonging to
any other bank.

Right now every train will create a task to notify it when a sensor was hit.
This was done so later when we need to track multiple trains in the system we
can use more complex logic to decide which sensors the current train has a
possibility of hitting helping us more carefully choose which sensors to show
interest in.

Using the \ttt{wh} command, and a train number, the current position
estimate for a train can be calculated and printed to the terminal. The
position is estimated using the last known sensor hit and the current
velocity. Acceleration information is not yet factored in to the
location of a train.

\section*{Path Finding}

In order to find the path from any given node on the track we make use of
Dijkstra's algorithm so that we can get the shortest path in terms of distance.
Since we don't yet support backwards path finding, reverse rules have
been excluded to ensure that no paths requiring reversing the train
will be generated by the algorithm. This will allow us to easily add
support for reverse paths later once the train driver is able to
handle the instructions.

The path is returned to the train driver as a collection of waypoints that the
train should expect to see on its way to reaching the destination along with
how far along the path the waypoint is. There are 3 different types of
waypoints returned by the train: first is the sensor waypoint, this is a sensor
that the train should expect to trip over the path to the destination; second
is the turnout waypoint, this is a track turnout and switch orientation that
that the driver must obey to keep the train routed on the same path; third is
the reverse way point, it indicates that the train must change its direction to
reach the next node.

Since reverse path are not currently supported the reverse waypoint is just used
to notify the driver that it is approaching its destination from the reverse
direction.

A path can be generated for the train using the \ttt{go} command and
specifying a train number, sensor bank, sensor number, and offset. For
example, \ttt{go 49 B 16 0} will send train 49 to sensor B16.


\part*{Milestone Two}

The goal of this milestone is to add the ability for multiple trains to be
controlled at at once. Due to the nature of having multiple trains
simultaneously running, this milestone sets up a system allowing for
trains to reserve sections of track and perform sensor attribution. On
top the features provided by the last milestone this milestone allows
for trains to perform short moves as well as for the trains to reverse
during the routing phase.

We found that the single task responsible for train control in
milestone one was becoming complex and difficult to manage. We elected
to re-implement all the features of milestone one in a more
distributed architecture.  Enabled by the extreme performance of our
kernel, we chose to use the internetworking model, which required that
we split train control into a hierarchy of server tasks which
communicate via couriers.

\section*{The Network}

The serial server which communicates with the train controller acts as the
physical and data link layers of the hierarchy. A task named
\ttt{Blaster} implements the network layer of the hierarchy and is
responsible for knowing the position of the train. The transport layer
of the hierarchy is responsible for train routing, and is implemented
by a task named \ttt{Master}. The application layer was never
fully realized, but would have been used to separate the logic of the
final project code from the positioning and routing code. Though we
never chose a name the task responsible for the application layer, it
would have followed the existing convention and been named after a
character from Mad Max Beyond Thunderdome
(\url{http://www.imdb.com/title/tt0089530/}).

We believe that using the names \ttt{Blaster} and
\ttt{Master} make it easier to remember the responsibilites of
the tasks in the hierarchy, though it does require some familiarity
with Mad Max lore.

A separate instance of the task hierarchy was created for each train.

\subsection*{Couriers}

In order for the server tasks to communicate in a non-blocking manner,
a variety of couriers were implemented.

Ephemeral couriers were used to get the effect of delayed and
asynchronous versions of \ttt{Send}. These were used mainly by
\ttt{Master} to send commands to \ttt{Blaster}.

Another ephemeral courier that was created is the timer courier. This
courier communicates directly with the clock server and simply acts as
an asynchronous call to \ttt{Delay} and \ttt{DelayUntil}, allowing
servers to be notified after a period of time without having to be
blocked during the call to the clock server.

Dedicated couriers were also created in order to establish
regular communictaion between two server tasks. Dedicated
communication channels exist between the \ttt{Blaster} and
\ttt{Master} for position updates, and between
\ttt{Blaster} and \ttt{Sensor Poller} for sensor attribution.

In order to support the number of tasks required to control a train,
our kernel was modified to support 512 concurrent tasks.
phase.

\section*{Positioning}

The positioning code present at milestone one was unable to properly
account for train position after acceleration events. Though we
collected data for this, we did not make use of it until the milestone
two time frame.

Using the data collected, we mapped stopping times to stopping
distances, as well as starting times and distances. Using these
functions we were able to model the position of the train after
acceleration to and from a stopped state with reasonable precision.

However, modeling of acceleration events between non-zero speeds is
not something that was covered by the data we collected during
development of milestone one. Some measurements were taken to try and
find the relationship between acceleration profiles of diffent
velocity deltas, but we were unable to figure out anything that worked
concretely. We suspect that the same acceleration curve is used for
each train and each velocity delta, and that getting the exact curve
is a matter of scaling the curve. Due to time constraints, we chose to
avoid rapid velocity changes for trains in order to keep the
positioning information accurate.

\ttt{Blaster} is responsible for train positioning logic, and used a
dedicated courier to \ttt{Master} to keep the current position
information synchronized.

The positioning information that \ttt{Blaster} kept was actually a
separate history of state for acceleration events, sensor events, and
virtual sensor events. When a new event occurred, the individual
history would try to merge into the main history, called the
\ttt{truth}, which was propagated to \ttt{Master} and other interested
tasks.

As this system was put into practice, we found that full histories for
each event type were not required, as a lot of redundant state was
stored for each event type. However, a different subset of each
history was relevant for each type of event in order to make sense of
what details needed to be merged into the \ttt{truth} state. Keeping
the full history was easier to trying to piece things together more
efficiently.

Earlier in development, we would have spent the time making this more
efficient, but as the final deadline approached we abandoned this goal
in favour of working on other requirements.

\subsection*{Reversing The Train}

Previously, the stopping time was estimated using a linear function
that we knew was sufficient for the train to stop. The reverse timing
logic was changed to use the stopping time mapping and became so
precise that reversing looked too mechanical. We added a small padding
of time so that reverses looked more realistic, as if a human was
driving the train and reacted to the train being stopped instead of
acting when the train was predicted to stop.

After reversing, the position of the train had to change to be an
offset from the reverse direction sensor of the next expected sensor
before reversing the train. Otherwise the train position would not
have made as much sense to the other tasks that tried to make use
of positioning information. Keeping the train a positive offset from a
sensor simplified the other tasks that would have otherwise had to
navigate in two directions on the track graph to make use of position
information.

\section*{Short Moves}

Short moves were implemented at the transport layer of the
architecture, in \ttt{Master}. Due to the limitations imposed
by the positioning system, short moves had to be done by computing the
highest speed at which the train could accelerate to and from a full
stop without overshooting the distance of the short move.

This would have allowed the train to move very short distances
precisely at low speeds, such as speed 1, and quickly for longer
distances using higher speeds.

However, degreadation of the trains caused the measurement to become
increasingly unreliable at low speeds. We attempted to compensate by
limiting the minimum speed that could be chosen to speed 6, but this
then limited the minimum distance that a train could
travel.

Eventually, we decided to allow the lower speeds and added a
runtime tweakable setting to allow fudging of acceleration
time. Unlike previous tweakable values, this value affected the
consant term in a linear function. Though this strategy is not
automatic, it seemed like a strategy that actually had a chance of
working as the track and trains continued to degrade and be repaired.

\section*{Sensor Attribution}

One of the goals of the second milestone was to control multiple
trains on the track at the same time, we needed to build on top of the
naive method that was used for the last milestone for single train
sensor attribution. We chose for the trains to use a more active
approach.

\subsection*{Train Console}

When a \ttt{Blaster} task is signalled to start moving it creates a
\ttt{Train Console} task for itself. This task is in charge of waiting for
sensors as well as waiting for a timeout when the train has expected to trigger
the next sensor. The console will then take which ever events fire and make a
decision of what to forward back to the \ttt{Blaster}. The
\ttt{Train Console} would start up a notifier for every sensor that it could
possibly hit within the future.

We chose this approach due to the nature of the hardware and since in a full
working state we would end up with a system that is very tolerant to hardware
failure. This system also fits nicely into the existing system we had set up
for use during the calibration of the trains.

One of the biggest issues we had with this system was that we needed to
synchronize the creation and use of sensor notifiers, a single timeout notifier
the courier that was used to deliver a command to the train for what has
happened position and with the sensor server to know when we want to get the
expired notifier back. This also required for us to keep the
\ttt{Train Console} in a synchronized state with the \ttt{Blaster} so we
can keep the positions of the train.

Due to the hard technical nature of this synchronization we we were never able
to get all of the edge cases worked out of this section of the code. This would
cause instances where this task will go into a deadlocked state waiting for one
of its observed sensors to be actuated. Since this task was responsible for
helping to verify train location this would cause for our train model model
tasks to also go into a mostly deadlocked state while the train continues to
move around the track. Unfortunately we had run out of time before we were able
to either make our current implementation less error prone or able to move to
another system required less precise methods of operation.

\subsection*{Sensor Farm}

The \ttt{Sensor Farm} is a server that maintains the state of all of the
sensors on the track. It will create a task \ttt{Sensor Poller} that gets when
a sensor has been actuated on the track and will notify the \ttt{Sensor Farm}
the time in which the event has been triggered. On top of Updating the UI over
which sensors have been actuated the \ttt{Sensor Farm} will also notify tasks
when a sensor has been triggered.

The sensor farm just maintains an of task ids to with each position in the
array corresponding to one of the sensors on the track. If multiple tasks try
to wait on the same sensor then the new task will be rejected unless the task
asking for the sensor notification belongs to a train owning the reservation of
the reverse direction. Since there is a noticeable amount of time for the
sensor event propagation to make it to the interested train the timestamp is
taken at the \ttt{Sensor Poll} level and passed along with the sensor event.

\section*{Reservations}

The way we handled reservations is by maintaining an active iteration similarly
to how the \ttt{Train Console} handles its task synchronization. This means that
every time a train asked for a reservation all of the previous reservations held
by the Train were dropped. This means that every time a reservation is performed
we needed to have a way of transferring the reservation list to the server. This
was done by blocking the original task and just reading the list out in place.
This was done because it was the easiest method of performing the operation.
Also, when the reservation was performed we needed to follow an action based on
whether the reservation was successful or not. This meant that performing the
operation in a synchronous manner also greatly simplified the code path.

Since our track graph was laid out such that every node corresponded to a point
on the graph and a direction we made our reservation system use the standard
track nodes as reservation points. In order to increase the precision of our
reservation system we made every node correspond to half of its forward edge.
This mean to own an entire edge of the graph a train would have to own both
nodes bordered by the track segment.

We chose to go with the automatic track dropping since coming up with a solution
to calculate a proper track node free list was sufficiently hard problem,
conversely, was much easier to calculate which segments of track the train would
require at any given moment given a position and a velocity.

The drawback of this method is that because sensors could cause the train
position to relocate instantly there would be times that the train is actually
unable to allocate the section of track that it is currently within. One of the
side effects that we had because of this is that the train would stop and go
into an infinite loop of stopping and trying to reacquire the section of track
its currently on. We were able to remove this loop by allowing for a train to
for allocate a section of track however by the end of the project we were unable
to implement a system to warn trains that a section of their reservation might
have been seized by someone else which can lead to collisions. This is
especially likely to happen when a Train has become lost and newly finds itself
but inside of another trains reservation.

\subsection*{Shortest Path Routing}

Finding the shortest path on the track with a single train using
Dijkstra's algorithm was reasonably easy. The challenge was how the
train would respond to the short moves and reverse commands in the
generated path.

The \ttt{Master} task, the transport level of the hierarchy, was now
responsible for train routing. It would break up a generated routes
into route chunks, separated at train reversing points. Each chunk of
the route would be treated as a short move, computing the ideal speed
to move at given the distance. The only difference between proper
short moves and routing short moves is that routing short moves were
able to adjust estimates based on sensor feedback.

For non-final chunks of the route, when the train had to stop in front
of a branching point on the track, we added a padding to the stopping
distance estimate, just in case the train stopped short of the
turnout. This helped us avoid multi-track drifting during train
routing. The amount of padding was configurable per-train, and could
be tweaked at runtime through the terminal using the \ttt{tk} command.

Routing was updated everytime a position update was received from
\ttt{Blaster}. If a train overshot the reverse by too much and hit two
sensors past the branch, then off-route behaviour of the train routing
would kick in and try to re-route the train to the destination. This
would sometimes produce a new route, causing the train to abort the
reverse operation and continue going around the track.

\subsection*{Tweakable Generalization}

The interface for adjusting tweakable values was generalized through
the \ttt{tk} command. Using the command, a train number, a tweak
number, and a tweak value; the tweak would be updated and reported
via the terminal.

For instance, \ttt{tk 56 3 100} would change the turnout padding
distance, using during routing, to be 100 millimeters.

\part*{Final Project: \underline{The Thunderdome}}

\section*{Path Finding Options}

\section*{Inter-train Communication}

\section*{The Chasing Game}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
