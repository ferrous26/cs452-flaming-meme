\documentclass[pdftex,10pt,a4paper]{article}
\usepackage{../cs452}
\usepackage{verbatim}

\begin{document}

\kernelmake{1}

\section*{Overview}

Our kernel implements a simple, constant time scheduler and task
descriptor system. The kernel handles system calls from tasks via
software interrupts and can run up to 64 tasks concurrently at 32
priority levels.

\section*{Operation Instructions}

A pre-compiled kernel exists at
\ttt{/u/cs452/tftp/ARM/marada/k1.elf}, which can be loaded with
default RedBoot command given in the course tutorial document:

\begin{center}
  \ttt{load -b 0x00218000 -h 10.15.167.4 ARM/marada/k1.elf; go}
\end{center}

The source code for the kernel exists in \ttt{/u3/marada/kernel1/},
and can be compiled with the following command chani:

\begin{center}
  \ttt{cd /u3/marada/kernel1 \&\& source /u3/marada/.cs452 \&\& make clean \&\& make}
\end{center}

Which will produce a \ttt{kernel.elf} file in the same directory as
the makefile.

The kernel and tasks consist of the following files:

\subsection*{Submitted Files}
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}


\newpage
\section*{Kernel1 Task Output}

When the kernel boots up, a very simple shell, simply named ``Task
Launcher'', is run as the default task. Pressing the \ttt{1} key on
the keyboard will run the task that performs the operations outlined by
the kernel1 assignment specification. Other tasks, meant for
profiling and testing the kernel, can be run using some of the other
keys. Pressing \ttt{h} will list all other available commands.

The output on screen should look like the following:

\verbatiminput{k1_task_out.txt}

\begin{description}
\item[Lines 1-3:] \hfill \\
  Standard output generated by the initialization sequence of the kernel.

\item[Lines 4-5:] \hfill \\
  The main task reports that it had created sub tasks with task
  identifiers 2 and 3 respectively. Since these tasks have a lower
  priority than the main task the kernel continues to schedule the main
  task and holds the current child task in the ready queue of their
  respective priority level.

\item[Lines 6-8:] \hfill \\
  The main task creates a subtask with task identifier 4. This task has
  a higher priority than the main task causing the kernel to schedule
  task 4 to run on the next context switch to user land. Since task 4
  has the highest priority in the system it runs until its execution
  is complete. After task 4 completes execution the kernel schedules
  the main task and the main task is notified that created task 4 and
  outputs the task creation message.

\item[Lines 9-11:] \hfill \\
  Output is similar to lines 6-8 however the created subtask has a task
  identifier of 5.

\item[Line 12:] \hfill \\
  The main task has performed all of its duties so it \ttt{Exit()}s.

\item[Lines 13-16:] \hfill \\
  The first 2 tasks created by the now zombified main task are the
  highest priority tasks in the scheduling queue. Since these 2 tasks
  are at the same priority level they will interleave their
  execution. This causes the output to flip messages between the two
  tasks until they reach the end of their execution at which point all
  of the non-system tasks have finished execution and the kernel
  schedules the task launcher to activate once again.

\end{description}


\newpage
\section*{Kernel Structure}

The kernel is organized into three sections: task descriptors,
scheduling, and system calls.

\subsection*{Task Descriptors}

Tasks metadata is stored in a static array of task descriptors. We
allow for up to 64 concurrent tasks. Each task descriptor contains the
task identifer \ttt{tid}, the parent task's task identifier
\ttt{p\_tid}, a priority level \ttt{priority}, a task index pointing
to the \ttt{next} scheduled task, some reserved space \ttt{reserved},
and the stack pointer for the current task \ttt{sp}.

The \ttt{tid} and \ttt{p\_tid} are stored as \ttt{int} types, simply
because it makes life easier in keeping with the required API for
\ttt{Create()}.

\ttt{priority} and \ttt{next} are stored as \ttt{unsigned char} types,
adding up to 16 bits, which necessitates the \ttt{reserved} space of
size \ttt{short int} in order to keep memory explicitly aligned. We
chose small sizes for those values to reduce the size of a task
descriptor in the hopes of leaving more cache space for other things
later. Explicit memory alignment is required by one of the many
warning flags we have enabled for GCC, and would have implicitly been
added to the structure when compiling with \ttt{-O2} or higher, which
we are using. Currently, a task descirptor requires four words of
memory, so we can fit two task descirptors on a single cache line with
our given architecture.

Finally, \ttt{sp} is declared as a \ttt{unsigned int*}; we avoided
using \ttt{void*} for \ttt{sp} because we want word sized indexing on
the user stack for manipulating the saved task context.

Task \ttt{state} is not stored in a task descriptor because we believe
that for the states; \ttt{ACTIVE}, \ttt{READY}, \ttt{BLOCKED}, and
\ttt{ZOMBIE}; that our scheduling and allocation logic will never
actually need check the state. This is certainly true at the moment,
but if this turns out to not be the case we can use our reserved task
descriptor space to store task state later.

\subsubsection*{Task Identifiers}

Task identifiers are assigned based on the array index of the task
descriptor. Each time that a descriptor is reused, the \ttt{tid} for
the descriptor is incremented by 64. This allows us to calculate the
array index for a descriptor in a single instruction given a
\ttt{tid}. It also trivializes the need to make sure two tasks never
have the same identifier.

Ensuring that task identifiers never repeat is not possible without
infinite memory and computation time, however, our strategy for
allocating identifiers does maximize the available number of
identifiers given the constraints of the API. Furthermore, task
descriptors are allocated in a round robin fashion, using a circular
buffer for a free list, so that the entire 31 bit space of valid
identifiers is used.

The \ttt{p\_tid} identier is set at task allocation time as that is
the only time that the parent is guaranteed to be alive. The parent of
a task is always the task that was active when we entered the kernel
to handle the system call and so this value is trivial to find.

\subsubsection*{Priority Levels}

Tasks have 32 priority levels. Level 0 is the lowest priority, level
31 is the highest priority. The range of priority levels fits nicely
into a bit field that is one word in length. This allows us to
optimize the scheduler selection process by checking for the highest
set bit in the bit field, which can be done reasonably efficiently by
calculating the integer logarithm with base 2 of the bit field (and
subtracting 1). The range of levels is also more than enough for what
professor suggested in class.

We found a constant time algorithm for calculating base 2 logarithms
on the internet. Proper attribution is given in the source code. We
also include a modified form of the algorithm optimized for short
integers, should we ever need to reduce our priority range to 16 in
order to save a few cycles of CPU time between context switches.

\subsubsection*{Priority Queues}

The \ttt{next} index of the descriptor is used as part of the
scheduler for maintaining the priority queue list. Storing the
priority queue within the descriptor table saves memory space
compared to creating individual queues for each priority level by
exploiting the fact that a task can only be in one queue at a time.

Should we ever have other types of scheduling queues, such as for
blocking, we can use the same \ttt{next} field of the descriptor, as
the task will only be in one queue at a time.

The memory savings will hopefully let the cache perform better when it
is evetually enabled by making more space for other things.

\subsubsection*{Task Context}

The \ttt{sp} is a pointer to the user stack where the task trap frame
is currently being stored. \ttt{sp} is the minimum runtime
information that the descriptor needs to store. All other information
is stored on the user stack in the trap frame.

When a task is created, we setup the initial stack for the user
process so that if the task falls off the end (does not \ttt{return}
explicitly), the \ttt{Exit()} function will implicitly be called. An
initial CPSR value is also setup on the stack such that the context
switch into the process will cause the CPSR to be correctly
initialized. And, of course, an initial program counter is set for the
task.

\subsection*{Scheduling}

The task scheduler is implemented as a bit field, which maps bits to
priority levels, and an array of \ttt{head} and \ttt{tail} pointers
which are indicies into the descriptor array. Technically, the rest of
the priority queue is stored within the task descriptors as described
above, but we do not duplicate explanations here.

When a task is scheduled, the scheduler is given the descriptor table
index so that the descriptor can be looked up.

Using the descriptor, the \ttt{priority} level can be looked up, and
the correct bit in the bit field can be turned on. Then the correct
pair of \ttt{head} and \ttt{tail} pointers can be looked up.

Using the values of the \ttt{tail} pointer, the descriptor that is
currently at the end of the list can have its \ttt{next} pointer
updated to point to the task being scheduled. If there is no other
task in the queue, then the \ttt{head} pointer is set instead.

The task being scheduled will always have its \ttt{next} pointer set
to \ttt{TASK\_MAX}. \ttt{TASK\_MAX} is set to 64, which is just
outside of the valid descriptor index range. This value is checked for
later when selecting the next task to activate as a signal that the
queue is empty and should have the appropriate bit in the bit field
turned off.

\subsubsection*{Activation Selection}

When the scheduler is asked to find the next task to be activated
during a system call, it will simply look for the highest bit set in
the bit field to select the priority queue and look up the \ttt{head}
pointer for that queue and then retrieve the correct task descriptor.

Then \ttt{head} is updated with \ttt{head->next}. If \ttt{head->next}
is \ttt{TASK\_MAX} then we know that the queue is empty and the bit
in the bit field should be turned off. This means that we can be sure
that the \ttt{head} pointer will be valid if the bit was turned on.

\subsubsection*{Activation}

Once all pointers are updated, the \ttt{task\_active} pointer, which
is the index of the active task, is set to the correct task. Once this
is done, a context switch will enter the newly activated task.

\subsection*{System Calls}

Context switching for system calls is done by \ldots

The immediate value associated with the \ttt{swi} instruction is not
used. Instead, we pass the system call number via \ttt{r0}. Additional
arguments for the system call are stored in a \ttt{kernel\_req}uest
structure on the task's stack and a pointer to the structure is left
in \ttt{r1}.

We added an \ttt{int myPriority()} system call to allow tasks to query
for their priority level. We imagine that some tasks will have the
same priority level in every instantiation of the task, while other
tasks may have a dynamic priority level for different
instantiations. As a task is not given its priority level during
instantiation, we needed a way to expose the information to tasks that
were interested. The \ttt{myPriority()} system call has the same
semantics as \ttt{myTid()} in that it will simply return a value
stored somewhere in the kernel and never fail.

Since a task descriptor stores the parent task identifier at creation
time, the semantics of \ttt{myParentTid()} in our implementation is
that the call will never fail and will always return the correct task
identifier for the parent task. Since we map a task identifier to a
specific descriptor in the descriptor array, it will be trivial to
check if the parent task is actually still alive for other system
calls that will be added for message passing.


\section*{Task Structure}

Maybe a few sentences about the required tasks and task launcher
\ldots

\subsection*{Bootstrap Task}

The bootstrap task actually uses the same code path for creating
itself as other tasks. The only trick required was that we had to set
an active task before any task is launched so that our task
initialization function could assign a parent task correctly. In our
system, the first task's parent task is itself.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
