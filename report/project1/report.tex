\documentclass[pdftex,10pt,a4paper]{article}
\usepackage{../cs452}

\begin{document}

\projectmake{1}

\section*{Overview}

This kernel development milestone adds the final set of kernel
features required for train control, namely serial I/O for both
the terminal and train controller. To demonstrate the finished kernel,
the M{\"a}rklin train set can be controlled by user input
to a terminal, and train track state is updated live on screen as the
trains travel around the track.

Commands issued into the terminal can manipulate trains and
switches, as well as monitor sensors. Trains can start, stop, toggle
lights and sound effects, and adjust speed. Switches can be toggled or
explicitly set to the straight or curved state.

The terminal displays information about current state
of the trains and switches, including a short history of the most
recent sensor activations. However, sensor activity cannot be
controlled by the user in any way.


\section*{Operation Instructions}

A pre-compiled kernel exists at
\ttt{/u/cs452/tftp/ARM/marada/m1.elf}, which can be loaded with
RedBoot using the following command:

\begin{center}
  \ttt{load -h 10.15.167.4 ARM/marada/m1.elf; go}
\end{center}

Notice that no offset should be specified for the load instruction.

The source code for the kernel exists in \ttt{/u3/marada/control1/},
and can be compiled with the following command chain:

\begin{center}
  \ttt{cd /u3/marada/kernel4 \&\& /u/cs444/bin/rake local}
\end{center}

Which will produce a \ttt{kernel.elf} file in the same directory as
the makefile, built in release mode with benchmarking enabled.

After Initialization the kernel will print
``\ttt{Welcome to Task Launcher}'' into the message logging area of
the screen and a command prompt will appear near the center of the
screen titled ``TERM> ''. At this point commands can be entered; keys
pressed should be echoed back at the command prompt in place of the
white cursor. Pressing the return key will confirm a command and cause
it to be processed. An online listing of the commands can be printed
by entering an empty command.

\subsection*{Submitted Files}
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info_headers.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}
\newpage
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info_impls.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}

\newpage
\section*{The Track}

To represent the track we use the data structure and data given on the
course web site. However, we have modified the data to store track
distances with extra (artificial) precision in order to avoid rounding
errors introduced by using integer math operations in calculations.

In addition, we have also remeasured track B to ensure that the given
data is accurate. In doing this remeasurement, we changed the fiducial
point of various track nodes to better categorize track nodes as being
straight or curved, which is used during calibration.

The remeaurement is used in combination with a classification for each
track section that is between a pair of sensors. The classification
allows us to assign different parameters to a train dependent on which
part of the track the train is currently travelling through. The
primary use for velocity estimates.

\section*{Train Calibration}

In order to measure train velocity, we calculated the time delta of
the train travelling between sensors at a constant speed
setting. Various sensor pairings were measured multiple times for each
of the trains.

For the sake of this milestone, we have limited the trains to speeds 6
through 12. We found that speeds lower than 6 often cause issues on
the track by getting the train stuck around corners, and speeds
greater than 12 have inconsistent and unpredictable measurements.

The different sensor pairings allow us to create baseline values for
each track node classification so that we can estimate a different
velocity for the train on a straight section of track compared to the
train trying to navigate around a corner.

We found that four different classifications: \ttt{STRAIGHT},
\ttt{CURVED}, \ttt{STRAIGHT\_TURNOUT}, \ttt{CURVED\_TURNOUT}.

In order to get acceleration profiles, we filmed one of each type of
train (except train 51) stopping at a sensor. Next to the track is a
measuring tape, and by counting frames taken to get to the next
measuring tape point, we were able to map the distance per time for a
trains acceleration and deceleration. The video was recorded at 60
frames per second to accomodate as much precision as possible, but
because the kernel itself has a clock running at 100 Hz, the velocity
measurements had a higher precision when measured with the computer.

\subsection*{Feedback}

Using the baseline values as a starting point, at runtime we are able
to adjust the velocity estimate of a train using a simple feedback
mechanism.

We have implemented a \ttt{dp} command to dump the velocity table for
an arbitrary train. The table is dumped in a CSV format which can
easily be copy-pasted into a file and later processed with a script to
generate C code for initializing the table.

Feedback has some safeties. The threshold. The alpha value.

\subsection*{Console Tweaking}

We allow for some of the navigation proprties of the trains to be modified via
terminal \ldots
write about Putin

\section*{Tracking}

Having to only have to track one train allows us to use all of the sensors to
make sure that it stays on the path.

we use distance measurements for paramaters, because speed and
consequently time, will vary from train to train, and track piece to
track piece.

\section*{Path Finding}

dijkstra is a cool dood and jsut want to eat his things

\section*{Couriers}

couriers, bitch. allow us to send things to other tasks without
blocking


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
