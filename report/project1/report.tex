\documentclass[pdftex,10pt,a4paper]{article}
\usepackage{../cs452}

\begin{document}

\projectmake{1}

\section*{Overview}

This development milestone adds basic train control functionality.
from the terminal you can both track in real time where the trains position
is on the track and route it to a sensor location. Train track state is updated
live on screen as the trains travel around the track.
trains travel around the track.

Commands issued into the terminal can manipulate trains and
switches, as well as monitor sensors. Trains can start, stop, toggle
lights and sound effects, and adjust speed. Switches can be toggled or
explicitly set to the straight or curved state.

The terminal displays information about current state
of the trains and switches, including a short history of the most
recent sensor activations. However, sensor activity cannot be
controlled by the user in any way.


\section*{Operation Instructions}

A pre-compiled kernel exists at
\ttt{/u/cs452/tftp/ARM/marada/m1.elf}, which can be loaded with
RedBoot using the following command:

\begin{center}
  \ttt{load -h 10.15.167.4 ARM/marada/m1.elf; go}
\end{center}

Notice that no offset should be specified for the load instruction.

The source code for the kernel exists in \ttt{/u3/marada/control1/},
and can be compiled with the following command chain:

\begin{center}
  \ttt{cd /u3/marada/kernel4 \&\& /u/cs444/bin/rake local}
\end{center}

Which will produce a \ttt{kernel.elf} file in the same directory as
the makefile, built in release mode with benchmarking enabled.

After Initialization the kernel will print
``\ttt{Welcome to Task Launcher}'' into the message logging area of
the screen and a command prompt will appear near the center of the
screen titled ``TERM> ''. At this point commands can be entered; keys
pressed should be echoed back at the command prompt in place of the
white cursor. Pressing the return key will confirm a command and cause
it to be processed. An online listing of the commands can be printed
by entering an empty command.

\subsection*{Submitted Files}
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info_headers.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}
\newpage
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info_impls.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}

\newpage
\section*{The Track}

To represent the track we use the data structure and data given on the
course web site. However, we have modified the data to store track
distances with extra (artificial) precision in order to avoid rounding
errors introduced by using integer math operations in calculations.

In addition, we have also remeasured track B to ensure that the given
data is accurate. While performing new measurements we changed the fiducial
point of various track nodes to better categorize track nodes as being
straight or curved for use during calibration.

The new measurements are used in combination with a classification for each
track section that is between a pair of sensors. The classification
allows us to assign different parameters to a train dependent on which
part of the track the train is currently travelling through. The
primary use for velocity estimates.

\section*{Train Calibration}

In order to measure train velocity, we calculated the time delta of
the train travelling between sensors at a constant speed
setting. Various sensor pairings were measured multiple times for each
of the trains.

For the sake of this milestone, we have limited the trains to speeds 6
through 12. We found that speeds lower than 6 often cause issues on
the track by getting the train stuck around corners, and speeds
greater than 12 have inconsistent and unpredictable measurements.

The different sensor pairings allow us to create baseline values for
each track node classification so that we can estimate a different
velocity for the train on a straight section of track compared to the
train trying to navigate around a corner.

We found that four different classifications: \ttt{STRAIGHT},
\ttt{CURVED}, \ttt{STRAIGHT\_TURNOUT}, \ttt{CURVED\_TURNOUT}.

In order to get acceleration profiles, we filmed one of each type of
train (except train 51) stopping at a sensor. Next to the track is a
measuring tape, and by counting frames taken to get to the next
measuring tape point, we were able to map the distance per time for a
trains acceleration and deceleration. The video was recorded at 60
frames per second to accommodate as much precision as possible, but
because the kernel itself has a clock running at 100 Hz, the velocity
measurements had a higher precision when measured with the computer.

\subsection*{Feedback}

Using the baseline values as a starting point, at runtime we are able
to adjust the velocity estimate of a train using a simple feedback
mechanism.

We have implemented a \ttt{dp} command to dump the velocity table for
an arbitrary train. The table is dumped in a CSV format which can
easily be copy-pasted into a file and later processed with a script to
generate C code for initializing the table.

Feedback has some safeties. The threshold. The alpha value.

\subsection*{Console Tweaking}

We allow for some of the navigation properties of the trains to be modified via
terminal \ldots
write about Putin

\section*{Tracking}

Since we only need to support tracking one train, we poll all of the sensors to
make sure that the train remain on the path calculated by the go command. the train
sets its position to be at the last sensor triggered and associates it with the time
the the sensor was triggered at. when ever the train is woken up it looks at the 
current time and recalculates its position using its stored velocity

we use distance measurements for parameters, because speed and
consequently time, will vary from train to train, and track piece to
track piece.

\section*{Path Finding}

In order to find the path from any given node on the track we make use of
Dijkstra's algorithm so we can get the shortest path in term's of distance.
Since we don't yet support backwards pathing rules have been excluded to
ensure that no backwards paths will be generated by the algorithm. This will
allow us to easily add support for reverse paths later once the functionality
has been designed.

The path is returned to the train driver as a collection of waypoints that the
train should expect to see on its way to reaching the destination along with
how far along the path the waypoint is. There are 3 different types of
waypoints returned by the train: first is the sensor waypoint, this is a sensor
that the train should expect to trip over the path to the destination; second
is the turnout waypoint, this is a track turnout and switch orientation that
that the driver must obey to keep the train routed on the same path; third is
the reverse way point, it indicates that the train must change its direction to
reach the next node.

Since reverse path are not currently supported the reverse waypoint is just used
to notify the driver that it is approaching its destination from the reverse
direction.

\section*{Couriers}



\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
