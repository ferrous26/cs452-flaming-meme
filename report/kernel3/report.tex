\documentclass[pdftex,10pt,a4paper]{article}
\usepackage{../cs452}

\begin{document}

\kernelmake{3}

\section*{Overview}

This kernel development milestone adds handling for hardware
interrupts, a clock server, and system calls for event handling and
communication with the clock server. This milestone also includes a
task that demonstrates the clock servers abilities.

\section*{Operation Instructions}

A pre-compiled kernel exists at
\ttt{/u/cs452/tftp/ARM/marada/k3.elf}, which can be loaded with
RedBoot using the following command:

\begin{center}
  \ttt{load -h 10.15.167.4 ARM/marada/k3.elf; go}
\end{center}

Notice that no offset should be specified for the load instruction.

The source code for the kernel exists in \ttt{/u3/marada/kernel2/},
and can be compiled with the following command chain:

\begin{center}
  \ttt{cd /u3/marada/kernel2 \&\& source /u3/marada/.cs452 \&\& make clean \&\& make}
\end{center}

Which will produce a \ttt{kernel.elf} file in the same directory as
the makefile built in debug mode with minimal optimizations enabled.

After Initialization the kernel will respond with the message ``\ttt{Welcome to
Task Launcher}''.
At this point the key \ttt{1} will start the clock server
demonstration. The \ttt{h} key will print a list of other commands
which are available to demonstrate features added in this milestone.

\subsection*{Submitted Files}
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}

\newpage
\section*{Hardware Interrupts}

\subsection*{AwaitEvent()}

The signature we chose for events is
\ttt{int AwaitEvent(int eventid, char* event, int eventlen)}. We chose
this in anticipation of handling UART FIFO I/O in the next
milestone. Using this API, the returned \ttt{int} will be \ttt{0} if
the event occurred normally and volatile data is now in the
\ttt{event} buffer that was given in the system call. The return value
will be \ttt{INVALID\_EVENT} (\ttt{-1}) if the given \ttt{eventid} is
not valid. No other return values are implemented for this milestone.

The contents of the \ttt{event} buffer after \ttt{AwaitEvent} returns
will depend on the event. For this milestone, only the
\ttt{CLOCK\_TICK} event is implemented, and will return once the clock
timer has signalled the CPU. The \ttt{CLOCK\_TICK} event does not put
any data into the \ttt{event} buffer as there is no meaningful data to
include. The \ttt{clock\_notifier} task, which is the notifier for the
\ttt{clock\_server} task, calls \ttt{AwaitEvent} as
\ttt{AwaitEvent(CLOCK\_TICK, NULL, 0)}.

Once the UART I/O is implemented, the \ttt{event} buffer will either
contain some bytes to be written, or be filled with bytes from the
UART. In the case of incoming data from a UART, the return from
\ttt{AwaitEvent} will be a positive value indicating how many bytes
were put into the \ttt{event} buffer.

\section*{Clock Server}




\section*{Kernel Changes}

Fixed bugs in task descriptor reuse.

Zero length messages can now be sent successfully.

\section*{Demonstration Output}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
