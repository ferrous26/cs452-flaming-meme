\documentclass[pdftex,10pt,a4paper]{article}
\usepackage{../cs452}
\usepackage{verbatim}

\begin{document}

\kernelmake{2}

\section*{Overview}

This kernel development milestone includes performant message
passing additions, as well as a name server used for task
co-operation. This milestone also includes a rock-paper-scissors
client and server that can be used to play games of the same name.

\section*{Operation Instructions}

A pre-compiled kernel exists at
\ttt{/u/cs452/tftp/ARM/marada/k2.elf}, which can be loaded with
default RedBoot command given in the course tutorial document:

\begin{center}
  \ttt{load -h 10.15.167.4 ARM/marada/k2.elf; go}
\end{center}

The source code for the kernel exists in \ttt{/u3/marada/kernel2/},
and can be compiled with the following command chain:

\begin{center}
  \ttt{cd /u3/marada/kernel2 \&\& source /u3/marada/.cs452 \&\& make clean \&\& make}
\end{center}

Which will produce a \ttt{kernel.elf} file in the same directory as
the makefile.

The kernel and tasks consist of the following files:

\subsection*{Submitted Files}
\begin{center}
\begin{tabular}{l|l}
  \bfseries File & \bfseries MD5 Hash
  \\\hline
  \csvreader[head to column names]{md5_info.csv}{}%
  {\\\file & \ttt{\hash}}%
\end{tabular}
\end{center}


\newpage
\section*{Message Passing}


\subsection*{Send}

\ttt{Send}ing a message follows the required API. When a \ttt{Send()}
call is made, we first look up the correct task descriptor for the
request. If the task identifier for the request is impossible, a
negative number, then the task identifier will still map to a valid
descriptor, but the request task identifier will not match the
descriptor task identifier.

If the request task identifier and descriptor task identifier do not
match, we check if the request task identifier was negative or not. If
the request task identifier is negative then the \ttt{Send()} call
returns immediately with the \ttt{IMPOSSIBLE\_TASK} (\ttt{-1}) error
code. If the task identifier is possible, but simply does not match
then the \ttt{INVALID\_TASK} (\ttt{-2}) error code is returned.

Finally, we check that the task descriptor itself is still valid. That
is, that it belongs to a live task. We track whether or not a task
is live by checking the \ttt{sp} member of the descriptor. The
\ttt{sp} is set to a valid address during task initialization, and is
set to \ttt{NULL} when the task \ttt{Exit}s. If the task is not alive,
then \ttt{Send} returns the \ttt{INVALID\_TASK} error code.

If all the checks pass, then we add the descriptor of the \ttt{Send}er
to the receive queue of the message receiver. We then check to see if
the receiver is \ttt{RECV\_BLOCKED}, and if it is, then we wake up the
receiver and effectively call \ttt{Receive} for the receiver.



Sending to yourself is undefined. Under the current implementation it
will cause the task to queue its message into its own receive queue,
and then enter a blocked state. A \ttt{Reply} cannot wake the task
because the task never enters the \ttt{RPLY\_BLOCKED} state.

Task state is stored in the task descriptor by using the \ttt{next}
pointer. The \ttt{next} pointer is also used as part of the priority
queue for scheduling. However, since a task will never be in a
scheduling priority queue while it is also blocked in a receive queue,
we use the same \ttt{next} pointer for both queues.

Taking that idea a step further, the \ttt{RECV\_BLOCKED} and
\ttt{RPLY\_BLOCKED} state information is stored in the \ttt{next}
pointer as well, as the \ttt{next} pointer will not be in use by
either the scheduling queues or the receive queues at the same
time. To be safe, the values used to represent \ttt{RECV\_BLOCKED} and
\ttt{RPLY\_BLOCKED} are not valid memory addresses on the given
hardware and will cause fault exceptions.


\subsection*{Receive}

\ttt{Receive} follows the required API. When a \ttt{Receive()} call is
made, we simply check if there are any task descriptors with messages
waiting in the receive queue for the caller.

If there are tasks in the receive queue, then the first task is popped
from the queue and its message is copied into the receivers
buffer. The sender enters the \ttt{RPLY\_BLOCKED} state and blocks
until it receives a \ttt{Reply} from some task, but the receiver is
scheduled to run again immediately.

If there are no waiting messages, then the caller will enter the
\ttt{RECV\_BLOCKED} state and block until it receives a message.

Receive queues are implemented almost identically to priority queues
for scheduling. Even the same \ttt{next} pointer is used in the task
descriptor structure for maintaining the receive queue.

If a tasks \ttt{Exit}s while there are descriptors in the receive
queue, the receive queue is emptied by waking up each task in the
queue and causing each tasks \ttt{Send} call to return with
\ttt{INCOMPLETE} (\ttt{-3}) error code.

Additionaly, if the buffer given with \ttt{Receive} does not have
enough space for the message at the front of the receive queue, then
the we wake up the \ttt{Send}er and return to it the
\ttt{NOT\_ENUF\_MEMORY} (\ttt{-4}) error code. In this case, the
receiver will recursively try to pop another message from the receive
queue or enter the \ttt{RECV\_BLOCKED} state.


\subsection*{Reply}

\ttt{Reply} follows the required API. When a \ttt{Reply()} call is
made, we first check that the task being replied to is valid. The
checks performed are a superset of the checks performed for
\ttt{Send}. \ttt{Reply} will also check the task being replied to is
actually in the \ttt{RPLY\_BLOCKED} state and waiting for a reply.

If the task being replied to is not expecting a \ttt{Reply} then we
return with the \ttt{INVALID\_RECVER} (\ttt{-3}) error code.

The final check performed for a \ttt{Reply} is to make sure that the
receiver of the reply has enough space in their reply buffer. If the
receiver of the reply does not have enough space, then the
\ttt{Reply}er will abort and return with the \ttt{NOT\_ENUF\_MEMORY}
(\ttt{-4}) error code.

If all checks pass, then the reply is copied to the reply buffer and
then both the receiver of the reply and the replyer will be scheduled
again (in that order).

\section*{Kernel Changes}

Task descriptors and the scheduling priority queues now use pointers
instead of descriptor indicies for lookups. We found that we were
using the indicies to find pointers anyways, so this made the code a
bit easier to read. Though, this does have an impact on our descriptor
size and we will measure the performance trade off once the data cache
can be exercised more thoroughly.

The logarithm algorithm used for choosing the priority queue during
scheduling has been changed. While both algorithms are constant time
calculations, the new algorithm uses a lookup table to replace two
extra calculations that the previous algorithm was performing. The
performance gain is approximately $0.2 \mu seconds$ for the
send/receiver/reply loop.

We have implemented a less naive \ttt{memcpy} and \ttt{memset} in ARM
assembly to replace the default implementation given by GCC.


\section*{Name Server}

The Nameserver is the first task that is started up on the
initialization of task launcher. Since the Nameserver is pivotal to
the proper operation of the OS if something goes wrong with the
initialization of the Nameserver the task launcher will abort causing
the kernel to terminate. Due to the importance and the requirement of
all tasks to be able to communicate with it the Task Launcher stores
the Nameserver’s task id in a global variable that all tasks are able
reach.

The Nameserver takes in a null terminated character sequence of no
more than 8 characters (including the null terminator) and provides a
querying task with the task id that corresponds to that string. If a
new task tries to register the same name as another task that
registered with the name server then the lookup will now point to the
task that registered most recently. The internal storage of the server
allows for up to 32 different lookups to be registered with it.

The API the Nameserver is split into 2 separate calls:
\begin{description}
\item[RegisterAs():] \hfill \\
This allows for a server to register itself with the name server for
other tasks find. Since this function is a wrapper around \ttt{Send()}
it will return all of the same errors as \ttt{Send()} and in addition
will use -69 to express that the server has no more space to store
task mappings.

\item[WhoIs():] \hfill \\
Allows for a querying task to find the task id of a task that had
registered itself before hand. Similarly to \ttt{RegisterAs()}, this
is a wrapper around the \ttt{Send()} system call and has the same
error codes but also contains the error -69 which means that the
lookup doesn’t lead to a valid task id.
\end{description}

The Nameserver stores all of the names into a single unsorted array
and all of the tasks that each name into a separate array such the the
index of both arrays correspond to the same element. Since the name
size is 8 characters or less the server does word comparison though
the name array until a match is found or all of the currently
registered names have been exhausted. The reason we used 8 as the size
is it allows for a sufficient large space of names and fits nicely
into two words so only two full comparisons need to be performed for
every name speeding up the liner search by a little while still
maintaining a simple approach for storage. Liner search was chosen due
to its simplicity and the Nameserver while important should only
require use during the initialization or when having a longer
operating time is of little consequence.


\section*{Rock Paper Scissors Output}


\verbatiminput{k2_task_out.txt}
(Note some blank lines have been removed)

\begin{description}
\item[Lines 1,2:] \hfill \\
As part of the Task Launchers initalization it calls \ttt{Create()} to
start up the RPS server. Since the RPS server has a higher priority
than the task launcher it then starts execution until it hits its
\ttt{Receive()} call. At this point the task launcher is the only
ready task in the system and it continues on until it busy waits for
user input.

\item[Lines 7-12:] \hfill \\
First Game

\item[Lines 17-22:] \hfill \\
Second Game

\item[Lines 27-32:] \hfill \\
Third Game

\item[Lines 37-42:] \hfill \\
Fourth Game
\end{description}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
